{
  "metadata": {
    "totalProblems": 5,
    "lastUpdated": "2025-08-30T15:33:12.229Z",
    "breakdown": {
      "Codechef": {
        "total": 1,
        "Easy": 1,
        "Medium": 0,
        "Hard": 0
      },
      "Gfg": {
        "total": 1,
        "Easy": 1,
        "Medium": 0,
        "Hard": 0
      },
      "Leetcode": {
        "total": 2,
        "Easy": 1,
        "Medium": 1,
        "Hard": 0
      },
      "Hackerrank": {
        "total": 1,
        "Easy": 0,
        "Medium": 1,
        "Hard": 0
      }
    }
  },
  "problems": [
    {
      "id": "codechef-easy-cost-of-groceries",
      "platform": "Codechef",
      "difficulty": "Easy",
      "problemName": "Cost of Groceries",
      "language": "java",
      "files": {
        "code": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int t = scanner.nextInt();\n\n        while (t-- > 0) {\n            int n = scanner.nextInt();\n            int x = scanner.nextInt();\n            int[] a = new int[n];\n            int[] b = new int[n];\n            \n            for (int i = 0; i < n; i++) {\n                a[i] = scanner.nextInt();\n            }\n            \n            for (int j = 0; j < n; j++) {\n                b[j] = scanner.nextInt();\n            }\n            int ans = 0;\n            for (int i = 0; i < n; i++) {\n                if (a[i] >= x) {\n                    ans += b[i];\n                }\n            }\n            \n            System.out.println(ans);\n        }\n        \n        scanner.close();\n    }\n}",
        "readme": "arrays\n\nCost of Groceries\n\nChef visited a grocery store for fresh supplies. There are \n𝑁\nN items in the store where the \n𝑖\n𝑡\nℎ\ni\nth\n item has a freshness value \n𝐴\n𝑖\nA\ni\n\t​\n\n and cost \n𝐵\n𝑖\nB\ni\n\t​\n\n.\n\nChef has decided to purchase all the items having a freshness value greater than equal to \n𝑋\nX. Find the total cost of the groceries Chef buys.\n\nInput Format\nThe first line of input will contain a single integer \n𝑇\nT, denoting the number of test cases.\nEach test case consists of multiple lines of input.\nThe first line of each test case contains two space-separated integers \n𝑁\nN and \n𝑋\nX — the number of items and the minimum freshness value an item should have.\nThe second line contains \n𝑁\nN space-separated integers, the array \n𝐴\nA, denoting the freshness value of each item.\nThe third line contains \n𝑁\nN space-separated integers, the array \n𝐵\nB, denoting the cost of each item.\nOutput Format\n\nFor each test case, output on a new line, the total cost of the groceries Chef buys.\n\nConstraints\n1\n≤\n𝑇\n≤\n100\n1≤T≤100\n1\n≤\n𝑁\n,\n𝑋\n≤\n100\n1≤N,X≤100\n1\n≤\n𝐴\n𝑖\n,\n𝐵\n𝑖\n≤\n100\n1≤A\ni\n\t​\n\n,B\ni\n\t​\n\n≤100\nSample 1:\nInput\nOutput\n4\n2 20\n15 67\n10 90\n3 1\n1 2 3\n1 2 3\n3 100\n10 90 50\n30 7 93\n4 50\n12 78 50 40\n40 30 20 10\n\n90\n6\n0\n50\n\nExplanation:\n\nTest case \n1\n1: Item \n2\n2 has freshness value greater than equal to \n𝑋\n=\n20\nX=20. Thus, Chef buys item \n2\n2. The total cost is \n90\n90.\n\nTest case \n2\n2: Items \n1\n,\n2\n,\n1,2, and \n3\n3 have freshness value greater than equal to \n𝑋\n=\n1\nX=1. Thus, Chef buys all \n3\n3 items. The total cost is \n1\n+\n2\n+\n3\n=\n6\n1+2+3=6.\n\nTest case \n3\n3: No item has freshness value greater than equal to \n𝑋\n=\n100\nX=100. Thus, Chef buys no items.\n\nTest case \n4\n4: Items \n2\n2 and \n3\n3 have freshness value greater than equal to \n𝑋\n=\n50\nX=50. Thus, Chef buys items \n2\n2 and \n3\n3. The total cost is \n30\n+\n20\n=\n50\n30+20=50.",
        "notes": "Conditional Summation\n\n          - Summary: The Java code utilizes two integer arrays, 'a' and 'b', of size 'n'. It reads 't' test cases, each consisting of 'n', 'x', array 'a', and array 'b' as input.  The code iterates through array 'a', and if an element is greater than or equal to 'x', the corresponding element from array 'b' is added to a running sum 'ans'. Finally, 'ans' is printed for each test case.  The Scanner class is used for input.\n\n          - Time Complexity: O(n*t), where 't' is the number of test cases and 'n' is the size of the arrays. This is because the code iterates through the arrays once for each test case.\n          - Space Complexity: O(n), dominated by the space used to store the arrays 'a' and 'b'. The space used for other variables is constant."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-30T15:33:12.065Z"
    },
    {
      "id": "gfg-easy-first-repeating-element",
      "platform": "Gfg",
      "difficulty": "Easy",
      "problemName": "First Repeating Element",
      "language": "java",
      "files": {
        "code": "// User function Template for Java\n\nclass Solution {\n    // Function to return the position of the first repeating element.\n    public static int firstRepeated(int[] arr) {\n        // Your code here\n        int n = arr.length;\n        HashMap<Integer, Integer> map = new HashMap<>();\n        int first = Integer.MAX_VALUE;\n        for(int i=0;i<n;i++){\n            if(map.containsKey(arr[i])){\n                int idx =map.get(arr[i]);\n                if(idx<first){\n                    first = idx;\n                }\n            }\n            else{\n                map.put(arr[i], i+1);\n            }\n        }\n        return (first == Integer.MAX_VALUE) ? -1 : first;\n    }\n}",
        "readme": "Arrays,Hash,Data_Structures\n\nFirst Repeating Element\nDifficulty: EasyAccuracy: 32.57%Submissions: 301K+Points: 2Average Time: 15m\n\nGiven an array arr[], find the first repeating element. The element should occur more than once and the index of its first occurrence should be the smallest.\n\nNote:- The position you return should be according to 1-based indexing. \n\nExamples:\n\nInput: arr[] = [1, 5, 3, 4, 3, 5, 6]\nOutput: 2\nExplanation: 5 appears twice and its first appearance is at index 2 which is less than 3 whose first the occurring index is 3.\nInput: arr[] = [1, 2, 3, 4]\nOutput: -1\nExplanation: All elements appear only once so answer is -1.\n\nConstraints:\n1 ≤ arr.size() ≤ 106\n0 ≤ arr[i] ≤ 106\n\nTry more examples\nExpected Complexities\nCompany Tags\nAmazonOracle\nTopic Tags\nRelated Articles\nReport An Issue\nIf you are facing any issue on this page. Please let us know.",
        "notes": "First Repeating Element\n\n          - Summary: The code uses a HashMap to store each integer from the input array `arr` as a key and its index (plus 1) as the value. It iterates through the array; if an integer is already in the HashMap, it means it's a repeated element. The algorithm updates `first` to the minimum index of the repeated element encountered so far. Finally, it returns the index of the first repeated element or -1 if no such element exists.\n\n          - Time Complexity: O(n) because the code iterates through the array once. HashMap operations (containsKey, get, put) take constant time on average.\n          - Space Complexity: O(n) in the worst case because the HashMap could store all unique elements from the array if there are no repeated elements."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-30T15:33:12.068Z"
    },
    {
      "id": "hackerrank-medium-simple-array-sum",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Simple Array Sum",
      "language": "java",
      "files": {
        "code": "import java.io.*;\nimport java.math.*;\nimport java.security.*;\nimport java.text.*;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.function.*;\nimport java.util.regex.*;\nimport java.util.stream.*;\nimport static java.util.stream.Collectors.joining;\nimport static java.util.stream.Collectors.toList;\n\nclass Result {\n\n    /*\n     * Complete the 'simpleArraySum' function below.\n     *\n     * The function is expected to return an INTEGER.\n     * The function accepts INTEGER_ARRAY ar as parameter.\n     */\n\n    public static int simpleArraySum(List<Integer> ar) {\n    // Write your code here\n      int sum =0;\n        for(int num : ar){\n            sum +=num;\n        }  \n        return sum;\n\n    }\n\n}\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(\"OUTPUT_PATH\")));\n\n        int arCount = Integer.parseInt(bufferedReader.readLine().trim());\n\n        List<Integer> ar = Stream.of(bufferedReader.readLine().replaceAll(\"\\\\s+$\", \"\").split(\" \"))\n            .map(Integer::parseInt)\n            .collect(toList());\n\n        int result = Result.simpleArraySum(ar);\n\n        bufferedWriter.write(String.valueOf(result));\n        bufferedWriter.newLine();\n\n        bufferedReader.close();\n        bufferedWriter.close();\n    }\n}",
        "readme": "null\n\nGiven an array of integers, find the sum of its elements.\n\nFor example, if the array , , so return .\n\nFunction Description\n\nComplete the  function with the following parameter(s):\n\n: an array of integers\n\nReturns\n\n: the sum of the array elements\n\nInput Format\n\nThe first line contains an integer, , denoting the size of the array.\nThe second line contains  space-separated integers representing the array's elements.\n\nConstraints\n\nSample Input\n\nSTDIN           Function\n-----           --------\n6               ar[] size n = 6\n1 2 3 4 10 11   ar = [1, 2, 3, 4, 10, 11]\n\n\nSample Output\n\n31\n\n\nExplanation\n\nPrint the sum of the array's elements: .",
        "notes": "Simple Array Sum\n\n          - Summary: The code uses a List (dynamic array) to store the input integers.  It iterates through this List, summing each element to calculate the total sum. The sum is then returned. The main function handles input/output, reading the array size and elements from the standard input and writing the result to the standard output.\n\n          - Time Complexity: O(n), where n is the number of elements in the input array. This is because the code iterates through the array once to calculate the sum.\n          - Space Complexity: O(n), where n is the number of elements in the input array. This is due to the space used to store the input array in memory.  The space used for the sum variable is constant."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-30T15:33:12.075Z"
    },
    {
      "id": "leetcode-easy-palindrome-number",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Palindrome Number",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public boolean isPalindrome(int x) {\n        int n = 0;\n        int orig = x;\n        if(x==0)\n        {\n            return true;\n        }\n        if (x < 0) {\n            return false;\n        }\n        while (x != 0) {\n            int rem = x % 10;\n            n = n * 10 + rem;\n            x = x / 10;\n        }\n        if (orig == n) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}",
        "readme": "Math\n\nGiven an integer x, return true if x is a palindrome, and false otherwise.\n\n \nExample 1:\n\nInput: x = 121\nOutput: true\nExplanation: 121 reads as 121 from left to right and from right to left.\n\n\nExample 2:\n\nInput: x = -121\nOutput: false\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n\n\nExample 3:\n\nInput: x = 10\nOutput: false\nExplanation: Reads 01 from right to left. Therefore it is not a palindrome.\n\n\n \nConstraints:\n\n\n\t-231 <= x <= 231 - 1\n\n\n \nFollow up: Could you solve it without converting the integer to a string?",
        "notes": "Palindrome Number\n\n          - Summary: The code uses integer variables to check if a given integer is a palindrome. It first handles the base cases of 0 and negative numbers.  Then, it iteratively reverses the input integer by extracting the last digit and prepending it to a new integer. Finally, it compares the original and reversed integers to determine if it's a palindrome.\n\n          - Time Complexity: O(log10(x)) because the while loop iterates roughly log10(x) times, where x is the input integer.  The number of digits in x determines the number of iterations.\n          - Space Complexity: O(1) because the algorithm uses a constant amount of extra space regardless of the input size. Only a few integer variables are used."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-30T15:33:12.070Z"
    },
    {
      "id": "leetcode-medium-longest-substring-without-repeating-characters",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Longest Substring Without Repeating Characters",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        HashMap<Character, Integer> hashMap = new HashMap<>();\n        int res = 0;\n        int wstart = 0;\n\n        for (int wend = 0; wend < s.length(); wend++) {\n            if (hashMap.containsKey(s.charAt(wend)) && wstart < hashMap.get(s.charAt(wend))){\n                wstart = hashMap.get(s.charAt(wend));\n            }\n            hashMap.put(s.charAt(wend), wend+1);\n            res = Math.max(res, wend-wstart+1);\n\n        }\n        return res;\n    }\n}",
        "readme": "HashTableStringSlidingWindow\n\nGiven a string s, find the length of the longest substring without duplicate characters.\n\n \nExample 1:\n\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\n\n\nExample 2:\n\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\n\n\nExample 3:\n\nInput: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n\n\n \nConstraints:\n\n\n\t0 <= s.length <= 5 * 104\n\ts consists of English letters, digits, symbols and spaces.",
        "notes": "Longest Substring Without Repeating Characters\n\n          - Summary: This Java code employs a HashMap to store characters as keys and their indices as values.  It iterates through the input string, using a sliding window approach.  If a repeating character is found within the current window, the window's start index is updated.  The algorithm maintains the maximum length of the substring without repeating characters, returning this length as the result.\n\n          - Time Complexity: O(n) because the code iterates through the string once. While the HashMap operations have average time complexity O(1), in the worst case they could be O(n), but this is very unlikely with a large dataset.  Hence, the overall time complexity remains linear.\n          - Space Complexity: O(min(m, n)) where n is the length of the string and m is the size of the character set. In the worst-case scenario, the HashMap could store all unique characters from the string, resulting in a space complexity proportional to the number of unique characters."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-30T15:33:12.073Z"
    }
  ]
}