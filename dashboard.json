{
  "metadata": {
    "totalProblems": 2,
    "lastUpdated": "2025-08-29T15:42:26.935Z",
    "breakdown": {
      "Codechef": {
        "total": 0,
        "Easy": 0,
        "Medium": 0,
        "Hard": 0
      },
      "Gfg": {
        "total": 1,
        "Easy": 1,
        "Medium": 0,
        "Hard": 0
      },
      "Leetcode": {
        "total": 1,
        "Easy": 0,
        "Medium": 1,
        "Hard": 0
      },
      "Hackerrank": {
        "total": 0,
        "Easy": 0,
        "Medium": 0,
        "Hard": 0
      }
    }
  },
  "problems": [
    {
      "id": "gfg-easy-first-repeating-element",
      "platform": "Gfg",
      "difficulty": "Easy",
      "problemName": "First Repeating Element",
      "language": "java",
      "files": {
        "code": "// User function Template for Java\n\nclass Solution {\n    // Function to return the position of the first repeating element.\n    public static int firstRepeated(int[] arr) {\n        // Your code here\n        int n = arr.length;\n        HashMap<Integer, Integer> map = new HashMap<>();\n        int first = Integer.MAX_VALUE;\n        for(int i=0;i<n;i++){\n            if(map.containsKey(arr[i])){\n                int idx =map.get(arr[i]);\n                if(idx<first){\n                    first = idx;\n                }\n            }\n            else{\n                map.put(arr[i], i+1);\n            }\n        }\n        return (first == Integer.MAX_VALUE) ? -1 : first;\n    }\n}",
        "readme": "Arrays,Hash,Data_Structures\n\nFirst Repeating Element\nDifficulty: EasyAccuracy: 32.57%Submissions: 301K+Points: 2Average Time: 15m\n\nGiven an array arr[], find the first repeating element. The element should occur more than once and the index of its first occurrence should be the smallest.\n\nNote:- The position you return should be according to 1-based indexing. \n\nExamples:\n\nInput: arr[] = [1, 5, 3, 4, 3, 5, 6]\nOutput: 2\nExplanation: 5 appears twice and its first appearance is at index 2 which is less than 3 whose first the occurring index is 3.\nInput: arr[] = [1, 2, 3, 4]\nOutput: -1\nExplanation: All elements appear only once so answer is -1.\n\nConstraints:\n1 ≤ arr.size() ≤ 106\n0 ≤ arr[i] ≤ 106\n\nTry more examples\nExpected Complexities\nCompany Tags\nAmazonOracle\nTopic Tags\nRelated Articles\nReport An Issue\nIf you are facing any issue on this page. Please let us know.",
        "notes": "First Repeating Element\n\n          - Summary: The code uses a HashMap to store each integer from the input array `arr` as a key and its index (plus 1) as the value. It iterates through the array; if an integer is already in the HashMap, it means it's a repeated element. The algorithm updates `first` to the minimum index of the repeated element encountered so far. Finally, it returns the index of the first repeated element or -1 if no such element exists.\n\n          - Time Complexity: O(n) because the code iterates through the array once. HashMap operations (containsKey, get, put) take constant time on average.\n          - Space Complexity: O(n) in the worst case because the HashMap could store all unique elements from the array if there are no repeated elements."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-29T15:42:26.803Z"
    },
    {
      "id": "leetcode-medium-longest-substring-without-repeating-characters",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Longest Substring Without Repeating Characters",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        HashMap<Character, Integer> hashMap = new HashMap<>();\n        int res = 0;\n        int wstart = 0;\n\n        for (int wend = 0; wend < s.length(); wend++) {\n            if (hashMap.containsKey(s.charAt(wend)) && wstart < hashMap.get(s.charAt(wend))){\n                wstart = hashMap.get(s.charAt(wend));\n            }\n            hashMap.put(s.charAt(wend), wend+1);\n            res = Math.max(res, wend-wstart+1);\n\n        }\n        return res;\n    }\n}",
        "readme": "HashTableStringSlidingWindow\n\nGiven a string s, find the length of the longest substring without duplicate characters.\n\n \nExample 1:\n\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\n\n\nExample 2:\n\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\n\n\nExample 3:\n\nInput: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n\n\n \nConstraints:\n\n\n\t0 <= s.length <= 5 * 104\n\ts consists of English letters, digits, symbols and spaces.",
        "notes": "Longest Substring Without Repeating Characters\n\n          - Summary: This Java code employs a HashMap to store characters as keys and their indices as values.  It iterates through the input string, using a sliding window approach.  If a repeating character is found within the current window, the window's start index is updated.  The algorithm maintains the maximum length of the substring without repeating characters, returning this length as the result.\n\n          - Time Complexity: O(n) because the code iterates through the string once. While the HashMap operations have average time complexity O(1), in the worst case they could be O(n), but this is very unlikely with a large dataset.  Hence, the overall time complexity remains linear.\n          - Space Complexity: O(min(m, n)) where n is the length of the string and m is the size of the character set. In the worst-case scenario, the HashMap could store all unique characters from the string, resulting in a space complexity proportional to the number of unique characters."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-29T15:42:26.806Z"
    }
  ]
}