{
  "metadata": {
    "totalProblems": 3,
    "lastUpdated": "2025-08-29T15:47:31.469Z",
    "breakdown": {
      "Codechef": {
        "total": 0,
        "Easy": 0,
        "Medium": 0,
        "Hard": 0
      },
      "Gfg": {
        "total": 1,
        "Easy": 1,
        "Medium": 0,
        "Hard": 0
      },
      "Leetcode": {
        "total": 1,
        "Easy": 0,
        "Medium": 1,
        "Hard": 0
      },
      "Hackerrank": {
        "total": 1,
        "Easy": 0,
        "Medium": 1,
        "Hard": 0
      }
    }
  },
  "problems": [
    {
      "id": "gfg-easy-first-repeating-element",
      "platform": "Gfg",
      "difficulty": "Easy",
      "problemName": "First Repeating Element",
      "language": "java",
      "files": {
        "code": "// User function Template for Java\n\nclass Solution {\n    // Function to return the position of the first repeating element.\n    public static int firstRepeated(int[] arr) {\n        // Your code here\n        int n = arr.length;\n        HashMap<Integer, Integer> map = new HashMap<>();\n        int first = Integer.MAX_VALUE;\n        for(int i=0;i<n;i++){\n            if(map.containsKey(arr[i])){\n                int idx =map.get(arr[i]);\n                if(idx<first){\n                    first = idx;\n                }\n            }\n            else{\n                map.put(arr[i], i+1);\n            }\n        }\n        return (first == Integer.MAX_VALUE) ? -1 : first;\n    }\n}",
        "readme": "Arrays,Hash,Data_Structures\n\nFirst Repeating Element\nDifficulty: EasyAccuracy: 32.57%Submissions: 301K+Points: 2Average Time: 15m\n\nGiven an array arr[], find the first repeating element. The element should occur more than once and the index of its first occurrence should be the smallest.\n\nNote:- The position you return should be according to 1-based indexing. \n\nExamples:\n\nInput: arr[] = [1, 5, 3, 4, 3, 5, 6]\nOutput: 2\nExplanation: 5 appears twice and its first appearance is at index 2 which is less than 3 whose first the occurring index is 3.\nInput: arr[] = [1, 2, 3, 4]\nOutput: -1\nExplanation: All elements appear only once so answer is -1.\n\nConstraints:\n1 ≤ arr.size() ≤ 106\n0 ≤ arr[i] ≤ 106\n\nTry more examples\nExpected Complexities\nCompany Tags\nAmazonOracle\nTopic Tags\nRelated Articles\nReport An Issue\nIf you are facing any issue on this page. Please let us know.",
        "notes": "First Repeating Element\n\n          - Summary: The code uses a HashMap to store each integer from the input array `arr` as a key and its index (plus 1) as the value. It iterates through the array; if an integer is already in the HashMap, it means it's a repeated element. The algorithm updates `first` to the minimum index of the repeated element encountered so far. Finally, it returns the index of the first repeated element or -1 if no such element exists.\n\n          - Time Complexity: O(n) because the code iterates through the array once. HashMap operations (containsKey, get, put) take constant time on average.\n          - Space Complexity: O(n) in the worst case because the HashMap could store all unique elements from the array if there are no repeated elements."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-29T15:47:31.444Z"
    },
    {
      "id": "hackerrank-medium-simple-array-sum",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Simple Array Sum",
      "language": "java",
      "files": {
        "code": "import java.io.*;\nimport java.math.*;\nimport java.security.*;\nimport java.text.*;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.function.*;\nimport java.util.regex.*;\nimport java.util.stream.*;\nimport static java.util.stream.Collectors.joining;\nimport static java.util.stream.Collectors.toList;\n\nclass Result {\n\n    /*\n     * Complete the 'simpleArraySum' function below.\n     *\n     * The function is expected to return an INTEGER.\n     * The function accepts INTEGER_ARRAY ar as parameter.\n     */\n\n    public static int simpleArraySum(List<Integer> ar) {\n    // Write your code here\n      int sum =0;\n        for(int num : ar){\n            sum +=num;\n        }  \n        return sum;\n\n    }\n\n}\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(\"OUTPUT_PATH\")));\n\n        int arCount = Integer.parseInt(bufferedReader.readLine().trim());\n\n        List<Integer> ar = Stream.of(bufferedReader.readLine().replaceAll(\"\\\\s+$\", \"\").split(\" \"))\n            .map(Integer::parseInt)\n            .collect(toList());\n\n        int result = Result.simpleArraySum(ar);\n\n        bufferedWriter.write(String.valueOf(result));\n        bufferedWriter.newLine();\n\n        bufferedReader.close();\n        bufferedWriter.close();\n    }\n}",
        "readme": "null\n\nGiven an array of integers, find the sum of its elements.\n\nFor example, if the array , , so return .\n\nFunction Description\n\nComplete the  function with the following parameter(s):\n\n: an array of integers\n\nReturns\n\n: the sum of the array elements\n\nInput Format\n\nThe first line contains an integer, , denoting the size of the array.\nThe second line contains  space-separated integers representing the array's elements.\n\nConstraints\n\nSample Input\n\nSTDIN           Function\n-----           --------\n6               ar[] size n = 6\n1 2 3 4 10 11   ar = [1, 2, 3, 4, 10, 11]\n\n\nSample Output\n\n31\n\n\nExplanation\n\nPrint the sum of the array's elements: .",
        "notes": "Simple Array Sum\n\n          - Summary: The code uses a List (dynamic array) to store the input integers.  It iterates through this List, summing each element to calculate the total sum. The sum is then returned. The main function handles input/output, reading the array size and elements from the standard input and writing the result to the standard output.\n\n          - Time Complexity: O(n), where n is the number of elements in the input array. This is because the code iterates through the array once to calculate the sum.\n          - Space Complexity: O(n), where n is the number of elements in the input array. This is due to the space used to store the input array in memory.  The space used for the sum variable is constant."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-29T15:47:31.450Z"
    },
    {
      "id": "leetcode-medium-longest-substring-without-repeating-characters",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Longest Substring Without Repeating Characters",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        HashMap<Character, Integer> hashMap = new HashMap<>();\n        int res = 0;\n        int wstart = 0;\n\n        for (int wend = 0; wend < s.length(); wend++) {\n            if (hashMap.containsKey(s.charAt(wend)) && wstart < hashMap.get(s.charAt(wend))){\n                wstart = hashMap.get(s.charAt(wend));\n            }\n            hashMap.put(s.charAt(wend), wend+1);\n            res = Math.max(res, wend-wstart+1);\n\n        }\n        return res;\n    }\n}",
        "readme": "HashTableStringSlidingWindow\n\nGiven a string s, find the length of the longest substring without duplicate characters.\n\n \nExample 1:\n\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\n\n\nExample 2:\n\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\n\n\nExample 3:\n\nInput: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n\n\n \nConstraints:\n\n\n\t0 <= s.length <= 5 * 104\n\ts consists of English letters, digits, symbols and spaces.",
        "notes": "Longest Substring Without Repeating Characters\n\n          - Summary: This Java code employs a HashMap to store characters as keys and their indices as values.  It iterates through the input string, using a sliding window approach.  If a repeating character is found within the current window, the window's start index is updated.  The algorithm maintains the maximum length of the substring without repeating characters, returning this length as the result.\n\n          - Time Complexity: O(n) because the code iterates through the string once. While the HashMap operations have average time complexity O(1), in the worst case they could be O(n), but this is very unlikely with a large dataset.  Hence, the overall time complexity remains linear.\n          - Space Complexity: O(min(m, n)) where n is the length of the string and m is the size of the character set. In the worst-case scenario, the HashMap could store all unique characters from the string, resulting in a space complexity proportional to the number of unique characters."
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": true,
      "lastUpdated": "2025-08-29T15:47:31.447Z"
    }
  ]
}